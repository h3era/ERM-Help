<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><title>Ресивер SN: новые команды</title>
<LINK REL="stylesheet" MEDIA="screen" TYPE="text/css" HREF="../style.css">
<script language="JScript" src="script.js"></script></head>

<body scroll="no">
<DIV id="buttonMenu">
<SPAN CLASS="options">Доп.&nbsp;опции&nbsp;SN:&nbsp;&nbsp;</SPAN>

 	<A HREF="#A" title="Получить адрес машинной функции" CLASS="button">A</A>
 <SPAN CLASS="buttoninactive" title="Работы с двоичными буферами на низком уровне: получить адрес локальной/статической глобальной переменных; чтение целого числа/строки с определённого адреса (или запись в этот адрес) и др.&#10;Команда доступна на ERA3+"><font color="red">B</font></SPAN>
 <SPAN CLASS="buttoninactive" title="Команда была упразднена, начиная с ERA 2.8.3.&#10;Однако, начиная с ERA 3.2.0 была вновь возвращена с уже новым назначением: получать постоянное значение по имени во время выполнения"><font color="red">C</font></SPAN>
 	<A HREF="#D" title="Обновление игровых экранов" CLASS="button">D</A>
 	<A HREF="#E" title="Выполнить машинную функцию" CLASS="button">E</A>
 	<A HREF="#F" title="Выполнить функцию, указав её аргументы" CLASS="button">F</A>
 	<A HREF="#G" title="Переход на определённую команду текущего триггера" CLASS="button">G</A>
 	<A HREF="#H" title="Работа с подсказками/названиями/описаниями" CLASS="button">H</A>
 	<A HREF="#I" title="Динамическая интерполяция строковых переменных" CLASS="button">I</A>
 	<A HREF="#K1" title="Получение размера строки, работа с символами строки, копирование блока памяти" CLASS="button">K</A>
 	<A HREF="#L" title="Подгрузка динамической библиотеки" CLASS="button">L</A>
 	<A HREF="#M" title="Работа с дополнительной памятью" CLASS="button">M</A>
 	<A HREF="#O" title="Получить координаты входа объекта на карте" CLASS="button">O</A>
 	<A HREF="#Q" title="Прервать обработку текущего события" CLASS="button">Q</A>
 	<A HREF="#R" title="Подмена ресурсов &quot;на лету&quot;" CLASS="button">R</A>
 	<A HREF="#T" title="Перевод строковых значений через ключ" CLASS="button">T</A>
 <SPAN CLASS="buttoninactive" title="Работа с элементами массива: позволяет устанавливать/проверять/получать/изменять
множество элементов динамического массива.&#10;Команда доступна на ERA3+"><font color="red">V</font></SPAN>
 	<A HREF="#W" title="Работа с ассоциативной памятью" CLASS="button">W</A>
 	<A HREF="#X" title="Доступ к параметрам новых событий" CLASS="button">X</A>
	<A style="position:absolute; right:4" href="#UP" CLASS="button" title="Вернуться к началу">&uarr;</a>

</DIV>

<DIV id="text">									
<blockquote id="Q2" class="erm">При помощи расширения стандартного ресивера <b>!!SN</b> были введены основные новые команды для <a href="../ERA/index.htm">ERA</a>.<br>
См. <a href="../Rec/SN.htm" title="Контроль воспроизведения звуков (WAV/82M)">описание стандартных команд !!SN</a></blockquote>

<a name="up"></a>
<p align="center"><font size="5">Ресивер <b>SN</b><a href="../ERA/index.htm" title="Работает только с ERA.."><img src="../Img/era.gif" class="TE"></a>: новые команды</font></p>
<p>
<br>Все команды ERA могут работать со следующими элементами ERM:</p><ul id="T0">
<li>Положительными и отрицательными числами;</li>
<li>Синтаксисом установки (без модификатора <i>&quot;d&quot;</i>) и получения (<b>?</b>) значений;</li>
<li>Переменными <i>y+</i>, <i>v</i>, <i>w</i>, <i>x</i>, <i>z+</i>, <i>f..t</i>, <i>e</i>;</li>
<li>Глобальными именованными переменными вида i^&hellip;^ (для чисел) и s^&hellip;^ (для строк);</li>
<li>Строковыми литералами в виде ^&hellip;^ с поддержкой спецификаторов %Y, %V, %W, %X, %Z, %I(&hellip;), %S(&hellip;), %T(&hellip;), %E с положительными индексами.</li>
</ul>
<p>Также, стоит отметить, что в отличии от стандартных <i>z</i>-переменных (длиной до 511 символов) строковые литералы ERA (^&hellip;^ или ^%S(&hellip;)^) могут иметь длину до 1млн. символов.</p>
<p>Более того, для всех команд новых ресиверов ERA (<a href="#">SN</a>/<a href="MP_era.htm">MP</a>/<a href="RD.htm">RD</a>) реализована поддержка:
<ul id="T0"><li>конкатенации строковых переменных (d&#</b>, где <b>#</b> - z-переменная или ^текст^);</li>
<li>числовых операций с модификатором <i>d</i> (d+, d-, d*, d:);</li>
<li>операций установки/получения для именованных переменных (SN:W-ключей) числового (i^имя^) и строкового (s^имя^) типов.</li></ul>
<b><u onclick="HideIt(1)" class="h">Примеры (<b id="show1">показать</b>)</u></b><div id="1" class="b">
<script type="erm">!!SN:W^Gold^/y1 W^Gold^/d-500 W^Gold^/d*11 W^Gold^/d:10; Gold = y1 -500 * 1.1

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!!SN:W^report^/^Сегодня мы напоролись на чужаков... Это были ^;
!!SN:W^report^/d&^орки!^;
!!IF:M^%S(report)^;</script>
На экране мы увидим:<span id="dl3">Сегодня мы напоролись на чужаков... Это были орки!</span></div></p>
<p>Ядро ERA передаёт командам набор целых чисел (<em>4 байта каждое</em>). В случае строк или синтаксиса получения значения, 
эти числа представляют собой адреса переменных. Адрес переменной – числовое значение, описывающее местоположение данных в оперативной памяти.<br>
Максимальное количество параметров команды: 64.</p>
<b><u onclick="HideIt(2)" class="h">Пример (<b id="show2">показать</b>)</u></b><div id="2" class="b">
<script type="erm">!!SN:Xv1; передать число в v1
!!SN:X?v1; передать адрес переменной v1
!!SN:Xz1; передать адрес переменной z1
!!SN:X^текст^; сохранить текст и передать его адрес
!!SN:Xe1 X?y1; перевести значение из float формата в dec</script></div>
</p>
<hr noshade>
<p><a name="L"></a><font id="red"><b>SN:L</b></font><br>
Подгрузка динамической библиотеки (DLL)</p>
<p>
<table cellpadding=3 border=1 id="le"><tr class="erm-line">
<td id="dl2"><b>L</b></td>
<td>путь к библиотеке</td>
<td style="border:0"><b>/</b>?</td>
<td>описатель загруженной библиотеки</td>
</tr></table><br>
<u>Пример</u>:
<script type="erm">!!SN:L^HD_WOG.dll^/?y2; игра с HD_mod? (y2=0 – игра без HD)</script>
</p>
<hr noshade>
<p><a name="A"></a><font id="red"><b>SN:A</b></font><br>
Получить адрес машинной функции из библиотеки </p>
<p>
<table cellpadding=3 border=1 id="le"><tr class="erm-line">
<td id="dl2"><b>A</b></td>
<td>описатель загруженной библиотеки</td>
<td style="border:0"><b>/</b></td>
<td><a href="../ERA/api.htm" class="event">название функции</a></td>
<td style="border:0"><b>/</b>?</td>
<td>адрес функции</td>
</tr></table><br>
<u>Пример</u>:
<script type="erm">!!SN:L^kernel32.dll^/?y1;
!!SN:Ay1/^lstrcpyA^/?y2;</script>
</p>
<hr noshade>
<p><a name="E"></a><font id="red"><b>SN:E</b></font><br>
Выполнить машинную функцию</p>
<pre id="Q1"><b>Соглашение о вызове:</b>
   0  (PASCAL)
   1  (CDECL или STDCALL)
   2  (THISCALL)
   3  (FASTCALL)</pre>
<p>По умолчанию от функции ожидается целочисленный результат, который будет помещён в переменную v1. Если же функция возвращает вещественный результат, 
то к номеру соглашения нужно прибавить 4 (сам же результат сохранится в e1). Все системные библиотеки используют соглашение <i class="file">STDCALL</i>.</p>
<p>
<table cellpadding=3 border=1 id="le"><tr class="erm-line">
<td id="dl2"><b>E</b></td>
<td>адрес функции</td>
<td style="border:0"><b>/</b></td>
<td>соглашение о вызове</td>
<td style="border:0"><b>/</b>аргументы&hellip;</td>
</tr></table><br>
<u>Примеры</u>:
<script type="erm">!!SN:L^kernel32.dll^/?y1;
!!SN:Ay1/^lstrcpyA^/?y2;
!!SN:Ey2/1/z1/z2; Скопировать содержимое z2 в z1. Аналог !!VRz1:Sz2;</script>
Получить ID текущего игрового диалога:
<script type="erm">!!SN:L^Era.dll^/?y2; получили описатель библиотеки ERA в y2
!!SN:Ay2/^GetGameState^/?y3; y3 - адрес функции GetGameState
!!SN:Ey3/1/?y4/?y5; y4 - ID родительского диалога, y5 - ID текущего диалога</script>
Вычисление корня квадратного на примере стороннего модуля:
<script type="erm">!!SN:L^math.era^/?y1;
!!SN:Ay1/^sqrt^/?y2;
!!VRe2:S169; будем извлекать квадратный корень из 169
!!SN:Ey2/5/e2; здесь 5 - соглашение STDCALL (1+4)
!!IF:M^e1=%E1^;</script>
</p>
<hr noshade>
<p><a name="F"></a><font id="red"><b>SN:F</b></font><br>
Выполнить функцию с указанными аргументами для её выполнения из библиотеки <i class="file">era.dll</i> или <i class="file">kernel32.dll</i> 
(ERA сама выберет нужную библиотеку для функции и закэширует её адрес по имени).<br>
Нет необходимости, в большинстве случаев, использовать последовательность команд SN:L&rarr;SN:A&rarr;SN:E.</p>
<p id="Q1">Используется соглашение <i class="file">STDCALL</i>.</p>
<p>
<table cellpadding=3 border=1 id="le"><tr class="erm-line">
<td id="dl2"><b>F</b></td>
<td><a href="../ERA/api.htm" class="event">название функции</a></td>
<td style="border:0"><b>/</b></td>
<td style="border:0">аргументы ф-ции&hellip;</td>
</tr></table><br>
<u>Примеры</u>:
<script type="erm">!!SN:F^ReadStrFromIni^/^key^/^section name^/^Data\test.ini^/?z2; аналог команды UN:N6

!!SN:F^CopyFileA^/^heroes3.ini^/^heroes3.ini.bak^/0; сделать резервную копию файла настроек игры

!!SN:F^GetButtonID^/^testBtn^; v1 получит ID кнопки

!!SN:F^PluginExists^/^era_hooker^; если v1=0, то плагин не найден</script>
</p>
<hr noshade>
<p><a name="D"></a><font id="red"><b>SN:D</b></font><br>
Перерисовать (обновить) экран героя, города, встречи двух героев, карты приключений.<br>
<b><u>Комментарий</u>:</b> команда более безопасна, чем аналогичная ей <a href="UN.htm#R">UN:R</a>.<br>
Команду следует использовать, непосредственно, в указанных выше игровых окнах, т.к. каждому игровому окну соответствует своя функция обновления и только для него.<br>
<u>Пример</u>:
<script type="erm">!?CM2; экран героя
!!CM:I?y1 T?y2;
!!FU|y1<>30720/y2<>512:E; если кликнули ПКМ на кнопке Выход
!!HE-1:L4/148; 		  сделать текущему герою лицо как у Гелу
!!SN:D;
</script>
</p>
<hr noshade>
<p><a name="G"></a><font id="red"><b>SN:G[имя]</b></font><br>
Переход на определённую команду текущего триггера.</p>
<blockquote id="Q2">На сегодня команда SN:G считается устаревшей и её использование в скриптах крайне не рекомендуется!<br>
Изначально команда создавалась как промежуточный вариант выполнения быстрых циклов. 
Сейчас предпочтительнее для этих целей использовать связку <a href="iee.htm">!!if</a> / <a href="re.htm">!!re</a>.</blockquote>
<p>Для выполнения переходов реализованы командные &laquo;ярлыки&raquo; (метки), которые заменяются на порядковый номер ресивера внутри текущего триггера, 
перед которым они стоят (отсчёт начинается с 0). В &laquo;счётчик&raquo; команд попадают все <b id="erm"><span class="re">!!XX</span></b>-подобные ресиверы. Самим меткам порядковый номер, как команде внутри триггера, не присваивается.<br>
Синтаксис использования следующий:
<dl><dd><b id="N2">[имя_метки]</b> – использование метки (будет заменено номером ресивера, для которого метка объявлена)</dd>
<dd><b id="N2">[:имя_метки]</b> – объявление метки (текущий номер ресивера запоминается и связывается с именем метки)</dd>
</dl></p>
<p>В качестве имени метки допускается любой произвольный текст. Использовать метки можно как до, так и после их объявления.<br>
Метки используются только с командой SN:G для выполнения циклов и условий.<br>
<u>Пример</u>:
<script type="erm">...
!!VRv1:S0 R10;
!!SN&v1>5:G[прыжок];
!!FU:E; "ЕРМ-забор" =)
[:прыжок]
!!IF:M^Вы перепрыгнули забор :)^;</script>
<b>ВАЖНО:</b> не разрешается использовать SN:G для &quot;прыжков&quot; как из структурных блоков, так и в структурные блоки.<br>
<u>Пример</u>:<br>
Для прерывания цикла есть команда <a href="re.htm#br_co">!!br</a>. Эмулировать SN:G можно так:
<script type="erm">!!re i/1/1; выполнить один раз блок
  ...
  !!br&условие:; выход из блока по условию
  ...
!!en:;</script></p>
<p><i>Старый синтаксис:</i><br>
<font id="red"><b>SN:G#</b></font> - переход на команду # (0&hellip;) текущего триггера.<br>
<b><u onclick="HideIt(6)" class="h">Пример (<b id="show6">показать</b>)</u></b><div id="6" class="b">
<script type="erm">!?CM0;
; ПКМ на карте приключений
;0 !!SN:G2; перейти на команду №2
;1 !!IF:M^Данный текст вы никогда не увидите!^;
;2 !!IF:M^Сейчас вы читаете это текст?^;
; Нумерация команд триггера приведена для наглядности</script></div>
</p>
<hr noshade>
<p><a name="H"></a><font id="red"><b>SN:H^xxx^&hellip;</b></font><br>
Команда позволяет работать с названиями/подсказками/описаниями без необходимости хранить текст в выделенных для этого <i>z</i>-переменных.<br>
На данный момент реализованы следующие типы команд SN:H:
<ul id="T0">
<li>^<a href="#H_mon">monname</a>^</li>
<li>^<a href="#H_obj">object</a>^</li>
<li>^<a href="#H_skl">secskill</a>^</li>
<li>^<a href="#H_spec">spec</a>^</li>
<li>^<a href="#" title="Команда доступна на ERA3+">art</a>^</li>
<li>^<a href="#" title="Команда доступна на ERA3+">spell</a>^</li></ul></p>
<p>Режим получения текста работает со всеми этими типами команд, давая возможность получать актуальный текст/описание в <i>z</i>-переменные для последующего вывода:
<script type="erm">...
!!SN:H^monname^/13/2/?z2;	получить в z2 описание архангела</script>
Для удаления (актуальных значений или установленных ранее через SN:H) или восстановления (стандартный текст) подсказок/описания используйте синтаксис <font id="red"><b>^-xxx^</b></font> &hellip;<br>
<u>Пример</u>:
<script type="erm">!!SN:H^-spec^/5/2/^^; восстановить описание специальности Сорше</script>
</p>
<hr noshade>
<p><a name="H_mon"></a><font id="red"><b>H^monname^/#1/#2/^текст^</b></font><br>
<font id="red"><b>H^monname^/#1/#2/?z#</b></font><br>
Изменение имени существ, их описания.
<pre>        #1 – <a target="form" href="../Form/Creature.htm">номер монстра</a>
        #2 – тип текста:
	0 – имя монстра в ед.ч.
	1 – имя монстра во мн.ч.
	2 – специальный текст (описание)</pre>
<b><u>Комментарий</u>:</b> команда отличается от аналогичной ей <a href="UN.htm#G1">UN:G1</a> тем, что не требует использования <i>z</i>-переменныx.</p>
<p><u>Пример</u>:
<script type="erm">Изменим имена и описания копейщиков:
!?PI;
!!SN:H^monname^/0/0/^Слабый^;
!!SN:H^monname^/0/1/^Больные^;		переименовать копейщика (1 = мн.ч.)
!!SN:H^monname^/0/2/^Разносит заразу^;  сменить описание (2) копейщика</script>
</p>
<hr noshade>
<p><a name="H_obj"></a><font id="red"><b>H^object^/X/Y/L/^текст^</b></font><br>
Установить подсказку для объекта на карте в координатах X Y L.<br>
<font id="red"><b>H^object^/#1/#2/^текст^</b></font><br>
Установить подсказку для объекта определённого типа/подтипа.
<pre>        #1 – <a target="form" href="../Form/Objects.htm">тип</a> (-1 = пропустить) 
        #2 – <a target="form" href="../Form/Objects.htm">подтип</a> (-1 = пропустить)</pre></p>
<p>Если используется несколько вариантов установки подсказок для одного объекта, то приоритет поиска подсказки таков:
<ol type="a"><li>объект с точными координатами</li>
<li>объект с указанными типом/подтипом</li>
<li>объект с указанным типом и подтипом -1</li>
<li>объект с типом -1 и указанным подтипом</li>
<li>объект c типом/подтипом как -1</li></ol>
<b><u>Комментарий</u>:</b> команда отличается от схожих с ней команды <a href="OB.htm#H">OB:H</a> и ресивера <a href="HT.htm">HT</a> тем, что не требует использования <i>z</i>-переменныx.</p>
<p><u>Пример</u>:
<script type="erm">!!VRz1:S^{Обледенелое озеро}
Осторожно, лёд очень тонкий!^;
!!SN:H^object^/121/-1/^%Z1^; установить свою подсказку для объекта 121 (замёрзшее озеро)</script>
</p>
<hr noshade>
<p><a name="H_skl"></a><font id="red"><b>H^secskill^/#1/#2/^текст^</b></font><br>
<font id="red"><b>H^secskill^/#1/#2/?z#</b></font><br>
Возможность установки текста вторичных навыков:
<pre>        #1 – <a target="form" href="../Form/SecondarySkill.htm">вторич.навык</a> (0..27)
        #2 – тип текста:
	0 – имя навыка
	1 – базовый уровень (описание)
	2 – продвинутый уровень (описание)
	3 – экспертный уровень (описание)</pre>
<b><u>Комментарий</u>:</b> команда отличается от аналогичной ей <a href="UN.htm#G">UN:G0</a> тем, что не требует использования <i>z</i>-переменныx.</p>
<p>
<u>Пример</u>:
<script type="erm">!!VRz5:S^тест^;
!!SN:H^secskill^/21/0/^%Z5^;	установить навыку обучение (21) название из z5
!!IF:M1/z5;			показать текст из z5
!!SN:H^-secskill^/21/0/^^;	вернуть стандартное название обучения
!!SN:H^secskill^/21/0/?z5;	получить в z5 текущее название навыка
!!IF:M1/z5;			показать текст из z5</script>
Вы получите два разных сообщения:<i id="dl3">тест</i> и <i id="dl3">Обучение</i>
</p>
<hr noshade>
<p><a name="H_spec"></a><font id="red"><b>H^spec^/#1/#2/^текст^</b></font><br>
<font id="red"><b>H^spec^/#1/#2/?z#</b></font><br>
Настроить свой текст для специализации героя
<pre>        #1 – <a target="form" href="../Form/NumberHeroes.htm">герой</a>
        #2 – тип текста для специализации:
	0 – название (не используется в игре)
	1 – краткое описание (не используется в игре)
	2 – полное описание</pre>
<b><u>Комментарий</u>:</b> команда отличается от аналогичной ей <a href="UN.htm#G2">UN:G2</a> тем, что не требует использования <i>z</i>-переменныx.</p>
<p><u>Пример</u>:
<script type="erm">!!HE-1:N?y1 B0/?z1;			получить номер и имя текущего героя
!!SN:H^spec^/y1/2/^{~red}Коддер{~}
Специализация %Z1: лютый коддинг!^; установить описание (2) спецухи этому же герою</script>
</p>
<hr noshade>
<p><a name="I"></a><font id="red"><b>SN:I</b></font><br>
Динамическая интерполяция строковых переменных.<br>
Команда может использоваться для интерполяции строковых переменных, получамых из внешних источников, таких как ini-файлы и команда <a href="#T">SN:T</a> 
(хотя её использование рекомендуется только для отладки и портирования).</p>
<p>
<table cellpadding=3 border=1 id="le"><tr class="erm-line">
<td id="dl2"><b>I</b></td>
<td>строковая переменная</td>
<td style="border:0"><b>/</b>?</td>
<td>z#</td>
</tr></table><br>
<u>Пример</u>:<br>
Допустим, в переменной z2 хранится следующее: <b id="erm"><font class="st">%Y5 %V996 текст %Z5</font></b><br>
Нам надо увидеть, какие значения каждая переменная содержит на данный момент.<br>
Для этого мы используем следующее:
<script type="erm">!!SN:Iz2/?z3;</script>
Теперь z3 содержит всю информацию из z2, включая все значения интерполированных переменных.</script>
</p>
<hr noshade>
<p><a name="O"></a><font id="red"><b>SN:O?X/?Y/?L</b></font><br>
Получить координаты входа объекта на карте.<br>
Команде передаются три числовые переменные с координатами объекта, в которые и будут записаны координаты входа объекта.<br>
<b><u onclick="HideIt(5)" class="h">Комментарии (<b id="show5">показать</b>)</u></b><div id="5" class="b">
<ul id="T0"><li>Если кликнуть на объекте без входа, команда возвращает координату объекта, где кликнули;</li>
<li>Если кликнуть на объекте с двумя и более входами, возвращает координату входа, который ближе к правому нижнему краю объекта.<br>
Если же кликнуть на любом из входов объекта, возвращает координату этого же входа.<br>
<i id="bold">Замечание:</i> команда вызывает сбои игры, если кликнуть на входе, где стоит другой герой.</li></ul>
<u>Пример</u>:<br>
Давайте узнаем координаты входа объекта, кликнув на другой части объекта&hellip;
<script type="erm">!?CM0; клик на карте
!!CM:R0 P?y1/?y2/?y3; получаем координаты объекта
!!VRv2:Cy1/y2/y3;     сохраняем копию координат в v2/v3/v4
!!SN:O?y1/?y2/?y3;    получаем координаты входа объекта
!!IF:M0/4/^%V2 %V3 %V4 => %Y1 %Y2 %Y3^; сравниваем наглядно</script></div>
</p>
<hr noshade>
<p><a name="Q"></a><font id="red"><b>SN:Q</b></font><br>
Прервать обработку текущего события<br>
<b><u>Комментарий</u>:</b> команда отличается от <a href="FU.htm#E">FU:E</a> тем, что прерывает всю цепочку однотипных триггеров.</p>
<p><u>Пример</u>:
<script type="erm">!?FU40000;
!!SN:Q; покинуть цепочку триггеров FU40000

!?FU40000;
!!IF:M^это сообщение никогда не будет показано^;

!?CM0;
!!FU40000:P; вызвать функцию 40000</script>
</p>
<hr noshade>
<p><a name="R"></a><font id="red"><b>SN:R</b></font><br>
Подменяет в игре &quot;на лету&quot; имена ресурсов.</p>
<p id="Q1">Используется соглашение <i class="file">STDCALL</i>.</p>
<p>
<table cellpadding=3 border=1 id="le"><tr class="erm-line">
<td id="dl2"><b>R</b></td>
<td>^старое имя файла^</td>
<td style="border:0">/</td>
<td>^новое имя файла^</td>
</tr></table><br>
Для сброса подмены файла укажите пустое значение вместо параметра "новое имя".<br>
<b><u onclick="HideIt(7)" class="h">Комментарии (<b id="show7">показать</b>)</u></b><div id="7" class="b">
Команда представляет собой обёртку над экпортируемой функцией <i class="event">RedirectFile</i> из <i class="file">era.dll</i>. Если более детально, то SN:R ни что иное как:
<script type="erm">!!SN:L^Era.dll^/?y1 Ay1/^RedirectFile^/?y2 Ey2/1/^старое^/^новое^;</script>
Все подмены файлов локальны, запоминаются в сохранениях игры и отменяются при выходе из игрового сценария (карты).<br>
Игра выгружает неиспользуемые ресурсы, поэтому большинство ресурсов могут динамически подменяться, пока вы играете.<br>
Если ресурс используется в Окне героя, выполняйте подмену перед тем, как откроется это окно (т.е. <a href="../ERA/new_events.htm#2.4">до кэширования ресурсов</a>).<br>
Пользовательские игровые фоны могут так же быть внедрены, давая возможность игроку переключать темы прямо во время игры 
(необходимо загрузить сохранение игры для визуального обновления).<br>
Указав шаблон <i class="file">*.mp3</i> для параметра "старое имя" подмена произойдёт для всех mp3-файлов сразу.</div>
</p>
<p><u>Примеры</u>:
<script type="erm">!#SN:R^cgriff.def^/^croc.def^; пусть Грифоны выглядят как Птицы Рух (только боевая модель)

!!SN:R^SNOW.MP3^/^my_snow.mp3^; подмена родной темы для поверхности "Снег" на свой трэк</script>
</p>
<hr noshade>
<p><a name="T"></a><font id="red"><b>SN:T^имя^/?z#/#1/?$1.../#7/?$7</b></font><br>
Позволяет получать переводы строк по ключам (произвольным уникальным строковым идентификаторам).<br>
В json-файлах хранятся пары вида &laquo;Ключ - Значение&raquo;, где значением является текст перевода с опциональными параметрами.
<pre>	(имя) – имя ключа
	z# – <i>z</i>-переменная для получения результата
	#1 – наименование параметра 1
	$1 – значение параметра 1
	&hellip;
	&hellip;
	#7 – наименование параметра 7
	$7 – значение параметра 7</pre>
<b><u onclick="HideIt(8)" class="h">Пример (<b id="show8">показать</b>)</u></b><div id="8" class="b">
<script type="erm">!!OW:R-1/6/?y1; y1 = кол-во золота у игрока
!!SN:T^test.gold_amount_report^/?z2/^gold^/y1; 
!!IF:M^%Z2^; покажет "У вас осталось 12850 золотых. Неплохо!"</script>
Мой test.json:<blockquote id="Q1"><pre class="erm">{
  "test.gold_amount_report": "У вас осталось @gold@ золотых. Неплохо!"
}</pre></blockquote></div></p>
<p id="Q1">См. также: <a href="../Cont/Json.htm">Выдержка из истории изменений ERA по json-файлам</a>
</p>
<hr noshade>
<p><a name="X"></a><font id="red"><b>SN:X</b></font><br>
Доступ к параметрам новых событий</p>
<p>
<table cellpadding=3 border=1 id="le"><tr class="erm-line">
<td id="dl2"><b>X</b></td>
<td>до 16 параметров</td>
<td style="border:0">&hellip;</td>
</tr></table><br>
Новые события ERA и добавляемые модулями события нуждаются в возможности обмениваться данными со скриптами. 
Эту возможность обеспечивает команда , выступающая в качестве хранилища значений. Тип значений определяется способом работы с ними. 
Так, можно установить в слот 0 значение 5, а потом получить его в вещественную <i>e</i>-переменную. 
Поскольку работа происходит на машинном уровне, то в <i>e</i>-переменной окажется вовсе не 5, а неопределённый мусор. 
В случае получения строковой переменной (текста), команда трактует значение в слоте как адрес. Поэтому, <b id="erm"><font class="re">!!SN</font>:X0; <font class="re">!!SN</font>:X?z1;</b> приведёт к вылету, 
т.к. по адресу 0 нет никакой строки.<br>
<u>Пример</u>:
<script type="erm">!!SN:Xz1; записать в 1ый параметр адрес строковой переменной z1
!!SN:X?y1; получить в y1 адрес z1</script>
Т.к. в ERA переменные x1..x16 доступны для любых триггеров, SN:X параметры и есть x1..x16.<br>
<i id="bold">Замечание:</i> на данный момент команда SN:X устарела, т.к. параметры событий можно читать/писать, обращаясь напрямую к x1..x16.<br>
<u>Пример</u>:
<script type="erm">!?(OnRecruitDlgRecalc);
!!VRx1:S777; = !!SN:X777;
!!VRy2:Sx1; = !!SN:X?y2;
!!VRy3:Cx1/x2; = !!SN:X?y3/?y4;</script>
Команду X целесообразно использовать только для редко требуемых операций по низкоуровневому преобразованию типов или получению адресов&hellip;
<script type="erm">!!SN:X?y1 Xs^мой текст^ X?y2 Xy1; получить в y2 адрес именованной переменной
Описание каждой команды в отдельности:
 » X?y1;		сохранить значение 1го параметра триггера
 » Xs^мой текст^;	передать в x1 адрес именованной строки
 » X?y2;		получить адрес именованной переменной
 » Xy1;			возвращаем значение 1го параметра триггера</script>
</p>
<hr noshade>
<h3><a name="M"></a>Работа с дополнительной памятью</h3>
<font id="red"><b>SN:M&hellip;</b></font>
<p>ERM переменные статичны и ограничены в количестве. 
Статичность приводит к невозможности организовывать динамические структуры данных (например, списки), 
для которых нужны функции выделения и освобождения памяти, 
а ограниченное количество ведёт к необходимости строгого учёта индексов без возможности выйти за их пределы. 
Более того, ERM строки в виде <i>z</i>-переменных занимают ровно 512 байт каждая в независимости от размера их содержимого. 
ERA предоставляет программисту до 2 млрд. слотов под массивы новых переменных (числовых или строковых). 
Размер массивов может изменяться средствами ERM. 
Поскольку работа с динамическими структурами предполагает автоматическое выделение номеров слотов, 
то такая возможность присутствует. Слоты с положительными индексами принадлежат пользователю, 
а с отрицательными используются при автовыделении памяти.<br>
<i id="bold">Замечание:</i> команды SN:M не поддерживают работу переменных с косвенными ссылками&hellip;
<script type="erm">!!SN:My1/y2/xy3; вызовет ошибку ЕРМ

Безопасный способ:
!!VRy4:Sxy3;
!!SN:My1/y2/y4;</script></p>
<hr noshade>
<p><a name="M1"></a><font id="red"><b>M#</b></font><br>
Удаление слота памяти</p>
<p>
<table cellpadding=3 border=1 id="le"><tr class="erm-line">
<td id="dl2"><b>M</b></td>
<td>номер слота, начиная с 0</td>
</tr></table><br>
<u>Пример</u>:
<script type="erm">!!SN:M5; удалить 6й слот</script>
</p>
<hr noshade>
<p><a name="M2"></a><font id="red"><b>M#1/$2</b></font><br>
Установка/получение размера слота<br>
(Размер слота – это количество элементов в массиве)</p>
<pre>        #1 – номер слота
        $2 – кол-во элементов</pre>
<p>Команда возвращает -1, если слот не существует.<br>
<u>Пример</u>:
<script type="erm">!!SN:M2/5; установить количество элементов в слоте 2 равное 5.
!!SN:My1/?y2; получить размер слота y1 в переменную y2.</script>
</p>
<hr noshade>
<p><a name="M3"></a><font id="red"><b>M#1/#2/$3</b></font><br>
Работа со значениями элементов слотов<br>
<pre>        #1 – номер слота
        #2 – номер элемента, начиная с 0
        $3 – значение</pre>
<u>Пример</u>:
<script type="erm">!!SN:M1/3; размер слота 1 = 3 элемента
!!SN:M1/0/111 M1/1/222 M1/2/333; содержимое слота 1: 111, 222, 333
!!SN:M1/1/?y5; y5 - содержимое 1-го элемента слота 1
!!IF:M^%Y5^; покажет: "222"</script>
</p>
<hr noshade>
<p><a name="M4"></a><font id="red"><b>M#1/?#2/#3</b></font><br>
Получение адреса элемента слота<br>
<pre>        #1 - номер слота
        #2 - адрес элемента (только получение)
        #3 - номер элемента</pre></p>
<p><b><u>Комментари</u>:</b> при удалении слота или изменении его размера – адрес станет недействительным!<br>
<b><u onclick="HideIt(9)" class="h">Примеры (<b id="show9">показать</b>)</u></b><div id="9" class="b">
<script type="erm">!!SN:M1/?y1/2; y1 содержит адрес 2-го элемента слота 1</script>
А вот другой пример, когда требуется скопировать строковое значение из массива в массив напрямую.<br>
Как уже было сказано ранее, все команды ERA получают параметры в виде 4-байтовых чисел. Для строк это обычно адрес первого символа. Когда мы пишем z1, команда получает адрес этой переменной. 
Когда строковое значение ^текст^ – строка сперва сохраняется во временном буфере, затем команде передаётся её адрес, после чего буфер освобождается..
<script type="erm">!!SN:M(src array)/?y1/(src index); записывает в y1 адрес первого символа строки в указанном массиве
!!SN:M(dst array)/(dst index)/y1; устанавливает новое значение элемента массива (команде передаётся адрес строки)
; команды ERA, принимающие строки, одинаково хорошо переваривают и адреса pchar'ов</script>
Таким образом, длинные строки (&gt;512 байт) можно копировать между собой и использовать как буфер для накопления:
<script type="erm">!!SN:M../../d&^ соединение строк^;</script></div>
</p>
<hr noshade>
<p><a name="M5"></a><font id="red"><b>M#1/#2/#3/#4</b></font><br>
Создание нового слота<br>
<pre>
        #1 – номер слота: "-1" для автовыделения свободного номера и помещения его в v1
        #2 – кол-во элементов в слоте
        #3 – тип элементов: 0 (число) и 1 (строка)
        #4 – запоминать ли значения в сохранёнках:
	= 0 (нет, при загрузке игры содержимое элементов будет представлять собой случайный мусор)
	= 1 (да, содержимое нужно сохранять как есть)</pre></p>
<p><b><u>Комментарий</u>:</b> старое содержимое слота (если оно было), уничтожается.<br>
Если значения в сохранениях не запоминать (#4=0), то экономится место в файле и возрастает скорость сохранения.<br>
<u>Пример</u>:
<script type="erm">!!SN:M0/4/1/1; выделить массив из 4-х строк в слоте 0. Сохранять их содержимое при загрузке
!!SN:M0/2/^привет^; установить значение 2-й строки слота 0
!!SN:M0/3/^мир^; установить значение 3-й строки слота 0
!!SN:M0/2/?z1 M0/3/?z2; получить значения 2-й и третьей строк в z1, z2
!!IF:M^%Z1 %Z2^; выведет "привет мир"
!!SN:M0; удалить слот 0
!!SN:M-1/0/0/0; выделить пустой слот под временный массив чисел
!!VRy1:S1 R6; сгенерировали случайное число 1..7
!!SN:Mv1/y1; установили размер нового слота в это число
!!VRy1:-1; y1 - индекс последнего элемента в слоте
!!SN:Mv1/y1/777; значение последнего элемента слота - 777</script>
</p>
<hr noshade>
<p><a name="K1"></a><font id="red"><b>SN:K&hellip;</b></font><br>
Команды SN:K работают как со строками (текстовыми переменными), так и с их адресами в памяти. 
Это делает SN:K более низкоуровневой и функциональной, чем схожие с ней по некоторым действиям команды <a href="VR.htm#M">VR:M#</a>.</p>
<p>
<font id="red"><b>K#1/?#2</b></font><br>
Получение размера строки (включая пробелы)</p>
<p>
<table cellpadding=3 border=1 id="le"><tr class="erm-line">
<td id="dl2"><b>K</b></td>
<td>строка или её адрес</td>
<td style="border:0"><b>/</b>?</td>
<td>размер строки</td>
</tr></table><br>
<u>Пример</u>:
<script type="erm">!!VRz1:S^123 4^;
!!SN:Kz1/?y1; y1 = 5</script>
</p>
<hr noshade>
<p><a name="K2"></a><font id="red"><b>K#1/#2/$3</b></font><br>
Работа с символами строки</p>
<p>
<table cellpadding=3 border=1 id="le"><tr class="erm-line">
<td id="dl2"><b>K</b></td>
<td>строка или её адрес</td>
<td style="border:0"><b>/</b></td>
<td>номер символа, начиная с 0</td>
<td style="border:0"><b>/</b>[?]</td>
<td>значение символа</td>
</tr></table><br>
<u>Пример</u>:
<script type="erm">!!VRz1:S^XYZ^;
!!SN:Kz1/2/^L^; установить 2-й символ строки z1 в "L"
!!IF:M^%Z1^; покажет нам "XYL"</script>
<i id="bold">Замечание:</i> синтаксис получения символа в $3 параметр работает некорректно.
</p>
<hr noshade>
<p><a name="K3"></a><font id="red"><b>K#1/#2/#3/#4</b></font><br>
Копирование блока памяти</p>
<p>
<table cellpadding=3 border=1 id="le"><tr class="erm-line">
<td id="dl2"><b>K</b></td>
<td>кол-во байт</td>
<td style="border:0"><b>/</b></td>
<td>адрес источника</td>
<td style="border:0"><b>/</b></td>
<td>адрес приёмника</td>
<td style="border:0"><b>/</b></td>
<td>произвольное значение</td>
</tr></table><br>
<b><u>Комментарий</u>:</b> поддерживаются числовые и строковые переменные.</p>
<p><u>Пример</u>:
<script type="erm">!!SN:K12/?v1/?y1/1; скопировать 12 байт (3 числа по 4 байта) из v1, v2, v3 в y1, y2, y3
!!VRv1:C1/2/3; v1 = 1, v2 = 2, v3 = 3
!!SN:K12/?y1/?v1/1; восстановить значения v1, v2, v3</script>
</p>
<hr noshade>
<h3><a name="W"></a>Работа с ассоциативной памятью</h3>
<font id="red"><b>SN:W[&hellip;]</b></font>
<p>Очень часто бывает нужно завести переменные для конкретных героев, конкретных клеток карты или объектов по запросам игрока.<br>
Выделение статической памяти для всех героев, всех объектов или всех клеток обладает существенными недостатками: 
чрезмерное потребление памяти, замедление процесса сохранения игры, ограниченность размеров.<br>
Все эти проблемы решаются при работе с глобальным хранилищем пар типа &laquo;Ключ - Значение&raquo;, напоминающем ini-файлы.<br>
Каждому ключу может соответствовать 1 числовое и 1 строковое значение.<br>
Значения 0/пусто не записываются в сохранения, что позволяет экономить место.<br>
При запросе несуществующего ключа будет возвращено 0/пусто, в зависимости от типа приёмника.<br>
<u>Пример</u>:<br>
Давайте создадим ключ и запишем в него значения разных типов, при этом они пересекаться не будут:
<script type="erm">!!SN:W^имя^/y1 W^имя^/z1;
!!SN:W^имя^/?y2 W^имя^/?z2; y2=y1, z2=z1</script>
</p>
<hr noshade>
<p><a name="W1"></a><font id="red"><b>W</b></font><br>
Полная очистка ассоциативной памяти</p>
<p><a name="W2"></a><font id="red"><b>W^имя^/$</b></font><br>
Работа с переменной</p>
<p>
<table cellpadding=3 border=1 id="le"><tr class="erm-line">
<td id="dl2"><b>W</b></td>
<td>имя переменной</td>
<td style="border:0"><b>/</b>[?]</td>
<td>значение переменной</td>
</tr></table><br>
<u>Пример</u>:<br>
Пусть щелчок правой кнопкой мыши на карте приключений приводит к отображению количества щелчков по данной клетке.<br>
Фактически, это аналог команды <a href="PO.htm">!!PO</a> по требованию.
<script type="erm">!?CM0;
!!CM:R0 P?y1/?y2/?y3;
!!SN:W^Map%Y1/%Y2/%Y3^/?y4;
!!VRy4:+1;
!!IF:L^{~gold}Вы щёлкнули на этой клетке %Y4 раз(а){~}^;
!!SN:W^Map%Y1/%Y2/%Y3^/y4;</script>
<i id="bold">Замечание:</i> внутри %I() нельзя использовать символ процентов (%).
</p>
<p><a name="W3"></a><font id="red"><b>W^имя^</b></font><br>
Удаление переменной
</p>
<hr noshade>
<p>&nbsp;</p>
</DIV>
<script src="../erm.js"></script></body></html>
